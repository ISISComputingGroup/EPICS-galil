# $File: //ASP/Dev/SBS/4_Controls/4_3_Network_Infrastructure/4_3_1_Comms_Common_Services/sw/device_drivers/Galil/1-5/galilSup/Db/galil_motor_withwrappers.template $
# $Revision: #1 $
# $DateTime: 2012/03/19 12:39:43 $
# $Author: cliftm $
#
# Description
# Template file for motor records
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# Licence as published by the Free Software Foundation; either
# version 2.1 of the Licence, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public Licence for more details.
#
# You should have received a copy of the GNU Lesser General Public
# Licence along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Contact details:
# mark.clift@synchrotron.org.au
# 800 Blackburn Road, Clayton, Victoria 3168, Australia.
#

grecord(motor,"$(P):$(M)")
{
	field(DTYP,"asynMotor")
	field(VMAX,"$(VMAX)")
	field(VBAS,"0")
	field(VELO,"$(VELO)")
	field(ACCL,"$(ACCL)")
	field(BDST,"$(BDST)")
	field(BVEL,"$(BVEL)")
	field(BACC,"$(BACC)")
	field(HVEL,"$(VELO)")
	field(OUT, "@asyn($(PORT),$(ADDR))")
	field(MRES,"$(MRES)")
	field(ERES,"$(ERES)")
	field(PREC,"$(PREC)")
	field(EGU,"$(EGU)")
	field(DHLM,"$(DHLM)")
	field(DLLM,"$(DLLM)")
	field(UEIP,"$(UEIP)")
    field(SREV,"$(SREV)")
	field(OFF,"$(OFF)")
	field(RTRY,"$(RTRY)")
	field(TWV,"1")
	field(DESC,"$(DESC)")
	field(SCAN,"Passive")
	field(FOFF,"1")
# PID gains
	field(PCOF,"$(PCOF)")
	field(ICOF,"$(ICOF)")
	field(DCOF,"$(DCOF)")
	field(HLSV,"MINOR")
	info(archive,"0.02 VAL RBV DVAL OFF MSTA DIR CNEN")
	info(alarm,"Motors")
}

alias("$(P):$(M)", "$(P):$(M):SP")

alias("$(P):$(M)", "$(P):$(M):SP:RBV")

record(transform,"$(P):$(M)_ableput") {
  field(CLCB,"a")
  field(CLCC,"a")
  field(OUTA,"$(P):$(M).DISA NPP NMS")
  field(OUTB,"$(P):$(M).DISP NPP NMS")
  field(OUTC,"$(P):$(M).DISA NPP NMS")
}

record(bo,"$(P):$(M)_able") {
  field(DESC,"motor enable")
  field(PINI,"YES")
  field(OUT,"$(P):$(M)_ableput.A PP MS")
  field(ZNAM,"Enable")
  field(ONAM,"Disable")
}

record(transform,"$(P):$(M)_lockput") {
  field(CLCB, "a = 0 ? 3 : 0")
  field(CMTB, "SPMG value")
  field(CMTA, "locked value")
  field(CLCC,"b")
  field(CLCD,"a")
  field(CLCE,"b")
  field(OUTC,"$(P):$(M).SPMG NPP NMS")
  field(OUTD,"$(P):$(M).DISP NPP NMS")
  field(OUTE,"$(P):$(M).SPMG NPP NMS")
}

record(bo,"$(P):$(M)_lock") {
  field(DESC,"Motor lock")
#  field(PINI,"YES")
  field(OUT,"$(P):$(M)_lockput.A PP MS")
  field(ZNAM,"Unlocked")
  field(ONAM,"Locked")
}

#Below records are used to extract data from MR
#and pass to driver
record(ao,"$(P):$(M)_ACCL_SP") {
    field(DESC, "Motor record ACCL")
    field(DOL,  "$(P):$(M).ACCL CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_ACCL")
    field(PREC, "$(PREC)")
}

record(ao,"$(P):$(M)_VMAX_SP") {
    field(DESC, "Motor record VMAX")
    field(DOL,  "$(P):$(M).VMAX CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_VMAX")
    field(PREC, "$(PREC)")
}

record(ao,"$(P):$(M)_VELO_SP") {
    field(DESC, "Motor record VELO")
    field(DOL,  "$(P):$(M).VELO CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_VELO")
    field(PREC, "$(PREC)")
}

record(ao,"$(P):$(M)_OFF_SP") {
    field(DESC, "Motor record OFF")
    field(DOL,  "$(P):$(M).OFF CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_OFF")
    field(PREC, "$(PREC)")
}

record(ao,"$(P):$(M)_MRES_SP") {
    field(DESC, "Motor record MRES")
    field(DOL,  "$(P):$(M).MRES CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_RESOLUTION")
    field(PREC, "$(PREC)")
}

record(ao,"$(P):$(M)_ERES_SP") {
    field(DESC, "Motor record ERES")
    field(DOL,  "$(P):$(M).ERES CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_ERES")
    field(PREC, "$(PREC)")
}

record(bo,"$(P):$(M)_DIR_SP") {
    field(DESC, "Motor record DIR")
    field(DOL,  "$(P):$(M).DIR CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynInt32")
    field(ZNAM, "Pos")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Neg")
    field(OSV,  "NO_ALARM")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_DIR")
}

record(bo,"$(P):$(M)_UEIP_SP") {
    field(DESC, "Motor record UEIP")
    field(DOL,  "$(P):$(M).UEIP CP MS")
    field(OMSL, "closed_loop")
    field(DTYP, "asynInt32")
    field(ZNAM, "No")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Yes")
    field(OSV,  "NO_ALARM")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_UEIP")
}

record(stringout,"$(P):$(M)_PREM_CMD")
{
	field(DESC, "Motor record PREM")
	field(OMSL, "closed_loop")
	field(DTYP, "asynOctetWrite")
	field(DOL,  "$(P):$(M).PREM CP MS")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_PREM")
}

record(stringout,"$(P):$(M)_POST_CMD")
{
	field(DESC, "Motor record POST")
	field(OMSL, "closed_loop")
	field(DTYP, "asynOctetWrite")
	field(DOL,  "$(P):$(M).POST CP MS")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_POST")
}

#driver to mr command to stop/go
#motors in coordsys
#set initial value of 3 so if running with motor simulator we don't get all motors in STOP 
record(ai,"$(P):$(M)_STOPGO_MON")
{
	field(DESC, "stop/go")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_STOPGO")
	field(VAL, 3)
}

record(ao, "$(P):$(M)_STOPGO_CMD") 
{
	field(OMSL, "closed_loop") 
	field(DOL,  "$(P):$(M)_STOPGO_MON CP MS")
	field(OUT,  "$(P):$(M).SPMG CA")
}

# monitor the motor status and update a string field with results
record(aSub, "$(P):$(M):_MSTACALC")
{
    field(SNAM, "displayMotorMSTA")
	field(INPA, "$(P):$(M).MSTA CP")
	field(FTA, "ULONG")
	field(OUTA, "$(P):$(M)_MSTA_STR PP")
	field(FTVA, "CHAR")
	field(NOVA, "512")	
}

record(waveform, "$(P):$(M)_MSTA_STR")
{
	field(NELM, "512")
	field(FTVL, "CHAR")
	field(DESC, "Text version of motor MSTA")
}

record(aSub, "$(P):$(M):_STATUSCALC")
{
    field(SNAM, "displayMotorMSTASimple")
	field(INPA, "$(P):$(M).MSTA CP")
	field(FTA, "ULONG")
	field(OUTA, "$(P):$(M)_STATUS PP")
	field(FTVA, "STRING")
	field(NOVA, "1")	
}

record(stringin, "$(P):$(M)_STATUS")
{
	field(DESC, "Simple Text version of motor MSTA")
}

record(stringin, "$(P):$(M)_MTR")
{
    field(VAL, "$(M)")
}

record(aSub,"$(P):$(M)_ERRCALC")
{
    field(SNAM,"checkMotorError")
    field(SCAN,"Passive")
    field(INPA,"$(P):$(M).MSTA CP")
	field(FTA, "ULONG")
    field(INPB,"$(P):$(M).LVIO CP")
	field(FTB, "SHORT")
    field(INPC,"$(P):$(M).HLS CP")
	field(FTC, "SHORT")
    field(INPD,"$(P):$(M).LLS CP")
	field(FTD, "SHORT")
    field(INPE,"$(P):$(M).STAT CP")
	field(FTE, "USHORT")
    field(INPF,"$(P):$(M).SEVR CP")
	field(FTF, "USHORT")
    field(INPG,"$(P):$(M)_MTR")
	field(FTG, "STRING")
	field(FTVA, "STRING")
	field(FTVB, "ULONG")
	# we want to process _ERRCALC_FAN only if the error message changes, so use OUTA not FLNK
	# but strings outputs cannot be used to write to .PROC fields, so need to use intermediate string record 
	field(OUTA, "$(P):$(M)_ERRCALC_MESS PP")
}

record(stringout, "$(P):$(M)_ERRCALC_MESS")
{
	field(FLNK, "$(P):$(M)_ERRCALC_FAN.PROC")
}

# on success VALB above == 0 and so fanout triggers no output, VALB == 1 causes OUTA to fire
# we want to record error messages, but not blanks on no error
record(fanout, "$(P):$(M)_ERRCALC_FAN")
{
	field(SELM, "Specified")
    field(SELL, "$(P):$(M)_ERRCALC.VALB NPP")
	field(LNK1, "$(P):$(M)_ERROR")
}

record(stringout,"$(P):$(M)_ERROR")
{
    field(OMSL, "closed_loop")
	field(DOL, "$(P):$(M)_ERRCALC.VALA NPP")
    field(DTYP, "stdio")
    field(OUT, "@errlog")
}

# Expose the DMOV field as a PV record, so it can be access from a block
record(ai,"$(P):$(M):DMOV")
{
	field(DESC, "Done move?")
    field(SCAN, "Passive")
    field(DTYP, "Soft Channel")
    field(INP, "$(P):$(M).DMOV CP")
}

# end
