# $File: //ASP/Dev/SBS/4_Controls/4_3_Network_Infrastructure/4_3_1_Comms_Common_Services/sw/device_drivers/Galil/1-5/galilSup/Db/galil_motor_extras.template $
# $Revision: #1 $
# $DateTime: 2012/03/19 12:39:43 $
# $Author: cliftm $
#
# Description
# Template file for motor extra commands/readbacks, that are additional to motor Record functionality
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# Licence as published by the Free Software Foundation; either
# version 2.1 of the Licence, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public Licence for more details.
#
# You should have received a copy of the GNU Lesser General Public
# Licence along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Contact details:
# cliftm@ansto.gov.au
# 800 Blackburn Road, Clayton, Victoria 3168, Australia.
#


record(bi,"$(P)$(M)_SCONN_STATUS")
{
	field(DESC, "SSI connection status")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(ZNAM, "Disconnected")
   	field(ZSV,  "MAJOR")

  	field(ONAM, "Connected")
  	field(OSV,  "NO_ALARM")

   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_SSI_CONNECTED")
}

record(bi,"$(P)$(M)_ESTALL_STATUS")
{
	field(DESC, "Encoder stall status")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(ZNAM, "Working Ok")
   	field(ZSV,  "NO_ALARM")

  	field(ONAM, "Stalled")
  	field(OSV,  "MAJOR")

   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_STATUS_SLIP")
}

#Time encoder stopped before declaring stall
record(ai,"$(P)$(M)_ESTALLTIME_MON")
{
	field(DESC,"estall time")
	field(DTYP,"asynFloat64")
	field(SCAN,"$(SCAN)")
	field(PREC,"$(PREC)")
	field(EGU, "s")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_ENCODER_STALL_TIME")
}

record(ao,"$(P)$(M)_ESTALLTIME_SP")
{
	field(DESC,"estall time")
	field(DTYP,"asynFloat64")
	field(PREC,"$(PREC)")
	field(EGU, "s")
	field(VAL, ".2")
	field(PINI, "YES")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_ENCODER_STALL_TIME")
	field(FLNK,"$(P)$(M)_ESTALLTIME_MON")
}

#Motor homing status, including JAH
record(bi,"$(P)$(M)_HOMING_STATUS")
{
	field(DESC, "Homing status")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(ZNAM, "No")
   	field(ZSV,  "NO_ALARM")
  	field(ONAM, "Yes")
   	field(OSV,  "NO_ALARM")
   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_HOMING")
}

#Overall/final homing status
record(calcout,"$(P)$(M)_HOMING_MONITOR")
{
	field(DESC, "Homing status")
	field(INPA, "$(P)$(M).HOMR CP MS")
	field(INPB, "$(P)$(M).HOMF CP MS")
	field(INPC, "$(P)$(M)_HOMING_STATUS CP MS")
	field(CALC, "A || B || C")
}

#Independent method of calling homr
record(bo,"$(P)$(M)_HOMR_CMD")
{
	field(DESC,"HOMR")
	field(DTYP,"asynInt32")
	field(VAL, "1")
	field(ZNAM,"HOMR")
	field(ZSV, "NO_ALARM")
	field(ONAM,"HOMR")
	field(OSV, "NO_ALARM")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_HOMR")
}

#Independent method of calling homf
record(bo,"$(P)$(M)_HOMF_CMD")
{
	field(DESC,"HOMF")
	field(DTYP,"asynInt32")
	field(VAL, "1")
	field(ZNAM,"HOMF")
	field(ZSV, "NO_ALARM")
	field(ONAM,"HOMF")
	field(OSV, "NO_ALARM")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_HOMF")
}

record(ai,"$(P)$(M)_STEPSMOOTH_MON")
{
	field(DESC,"Step smoothing")
	field(DTYP,"asynFloat64")
	field(SCAN,"$(SCAN)")
	field(PREC,"$(PREC)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_STEPSMOOTH")
}

record(ao,"$(P)$(M)_STEPSMOOTH_SP")
{
	field(DESC, "Step smooth sp")
	field(DTYP, "asynFloat64")
	field(DRVL, "0.5")
	field(DRVH, "16.0")
	field(PREC, "$(PREC)")
	field(PINI, "YES")
	field(VAL,  "1.313")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_STEPSMOOTH")
	field(FLNK,"$(P)$(M)_STEPSMOOTH_MON")
}

record(ai,"$(P)$(M)_ITCSMOOTH_MON")
{
	field(DESC,"Ind Time Const smooth func")
	field(DTYP,"asynFloat64")
	field(SCAN,"$(SCAN)")
	field(PREC,"$(PREC)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_ITCSMOOTH")
}

record(ao,"$(P)$(M)_ITCSMOOTH_SP")
{
	field(DESC, "Ind Time Const smooth func sp")
	field(DTYP, "asynFloat64")
	field(DRVL, "0.004")
	field(DRVH, "1.0")
	field(PREC, "$(PREC)")
	field(PINI, "YES")
	field(VAL,  "1.0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_ITCSMOOTH")
	field(FLNK,"$(P)$(M)_ITCSMOOTH_MON")
}

record(ai,"$(P)$(M)_POLE_MON")
{
	field(DESC,"PID Filter param")
	field(DTYP,"asynFloat64")
	field(SCAN,"$(SCAN)")
	field(PREC,"$(PREC)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_POLE")
}

record(ao,"$(P)$(M)_POLE_SP")
{
	field(DESC,"PID Filter param sp")
	field(DTYP, "asynFloat64")
	field(DRVL, "0.0")
	field(DRVH, "0.9999")
	field(PREC, "$(PREC)")
	field(PINI, "YES")
	field(VAL,  "0.0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_POLE")
	field(FLNK,"$(P)$(M)_POLE_MON")
}

record(ai,"$(P)$(M)_BIASVOLTAGE_MON")
{
	field(DESC,"Motor bias voltage")
	field(DTYP,"asynFloat64")
	field(SCAN,"$(SCAN)")
	field(PREC,"$(PREC)")
	field(EGU, "V")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BIASVOLTAGE")
}

record(ao,"$(P)$(M)_BIASVOLTAGE_SP")
{
	field(DESC,"Motor bias voltage sp")
	field(DTYP, "asynFloat64")
	field(DRVL, "-9.998")
	field(DRVH, "9.998")
	field(PREC, "$(PREC)")
	field(EGU, "V")
	field(PINI, "YES")
	field(VAL,  "0.0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_BIASVOLTAGE")
	field(FLNK,"$(P)$(M)_BIASVOLTAGE_MON")
}

record(bi,"$(P)$(M)_MCONN_STATUS")
{
	field(DESC, "Connect stat")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(ZNAM, "Disconnected")
	field(ZSV,  "MINOR")
	field(ONAM, "Connected")
	field(OSV,  "NO_ALARM")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_MCONN")
}

record(bi,"$(P)$(M)_UINDEX_STATUS")
{
	field(DESC, "use index")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(SCAN, "$(SCAN)")
	field(ZNAM, "No")
	field(ZSV,  "NO_ALARM")
	field(ONAM, "Yes")
	field(OSV,  "NO_ALARM")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_USEINDEX")
}

record(bo,"$(P)$(M)_UINDEX_CMD")
{
	field(DESC,"use index")
	field(DTYP,"asynInt32")
	field(VAL, "1")
	field(PINI,"YES")
	field(ZNAM,"No")
	field(ZSV, "NO_ALARM")
	field(ONAM,"Yes")
	field(OSV, "NO_ALARM")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_USEINDEX")
	field(FLNK,"$(P)$(M)_UINDEX_STATUS")
}

record(bi,"$(P)$(M)_USWITCH_STATUS")
{
	field(DESC, "use switch")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(SCAN, "$(SCAN)")
	field(ZNAM, "No")
	field(ZSV,  "NO_ALARM")
	field(ONAM, "Yes")
	field(OSV,  "NO_ALARM")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_USESWITCH")
}

record(bo,"$(P)$(M)_USWITCH_CMD")
{
	field(DESC,"use switch")
	field(DTYP,"asynInt32")
	field(VAL, "1")
	field(PINI,"YES")
	field(ZNAM,"No")
	field(ZSV, "NO_ALARM")
	field(ONAM,"Yes")
	field(OSV, "NO_ALARM")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_USESWITCH")
	field(FLNK,"$(P)$(M)_USWITCH_STATUS")
}

record(ai,"$(P)$(M)_USERDATA_MON")
{
	field(DESC, "User data")
	field(DTYP, "asynFloat64")
	field(SCAN, "I/O Intr")
	field(PREC, "$(PREC)")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_USER_DATA")
}

record(ao,"$(P)$(M)_USERDATADEADB_SP")
{
	field(DESC, "User data deadb")
	field(DTYP, "asynFloat64")
	field(VAL,  "1")
	field(PINI, "YES")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_USER_DATA_DEADB")
}

record(bi,"$(P)$(M)_JAH_STATUS")
{
	field(DESC, "Jog after home")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(SCAN, "$(SCAN)")
	field(ZNAM, "No")
	field(ZSV,  "NO_ALARM")
	field(ONAM, "Yes")
	field(OSV,  "NO_ALARM")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_JOG_AHOME")
}

record(bo,"$(P)$(M)_JAH_CMD")
{
	field(DESC,"Jog after home")
	field(DTYP,"asynInt32")
	field(VAL, "0")
	field(PINI,"YES")
	field(ZNAM,"No")
	field(ZSV, "NO_ALARM")
	field(ONAM,"Yes")
	field(OSV, "NO_ALARM")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_JOG_AHOME")
	field(FLNK,"$(P)$(M)_JAH_STATUS")
}

record(ai,"$(P)$(M)_JAHV_MON")
{
	field(DESC,"Jog after home val")
	field(PINI,"YES")
	field(EGU, "$(EGU)")
	field(DTYP,"asynFloat64")
	field(SCAN,"$(SCAN)")
	field(PREC,"$(PREC)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_JOG_AHOME_VALUE")
}

record(ao,"$(P)$(M)_JAHV_SP")
{
	field(DESC,"Jog after home val")
	field(DTYP,"asynFloat64")
	field(EGU, "$(EGU)")
	field(PREC,"$(PREC)")
	field(VAL, "0")
	field(PINI,"YES")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_JOG_AHOME_VALUE")
	field(FLNK,"$(P)$(M)_JAHV_MON")
}

record(ai,"$(P)$(M)_EGUAFTLIMIT_MON")
{
	field(DESC,"Egu after limit")
	field(PINI,"YES")
	field(EGU, "$(EGU)")
	field(DTYP,"asynFloat64")
	field(SCAN,"$(SCAN)")
	field(PREC,"$(PREC)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_EGUAFTER_LIMIT")
}

record(ao,"$(P)$(M)_EGUAFTLIMIT_SP")
{
	field(DESC,"EGU after limit")
	field(DTYP,"asynFloat64")
	field(EGU, "$(EGU)")
	field(PREC,"$(PREC)")
	field(VAL, "0.001")
	field(PINI, "YES")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_EGUAFTER_LIMIT")
	field(FLNK,"$(P)$(M)_EGUAFTLIMIT_MON")
}

record(mbbi,"$(P)$(M)_LIMITCONSISTENT_STATUS")
{
	field(DESC, "motor limit consistent")
	field(SCAN, "I/O Intr")
	field(DTYP, "asynInt32")
	field(ZRST, "Unknown")
	field(ONST, "Consistent")
	field(TWST, "Not consistent")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_LIMIT_CONSISTENT")
}

record(mbbi,"$(P)$(M)_SSIINPUT_STATUS")
{
	field(DESC, "ssi input")
	field(SCAN,"$(SCAN)")
	field(DTYP, "asynInt32")
	field(ZRST, "Off")
	field(ONST, "Replace main")
	field(TWST, "Replace aux")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_SSIINPUT")
}

record(ai,"$(P)$(M)_SSITOTBITS_MON")
{
	field(DESC,"SSI totalbits")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_SSITOTBITS")
}

record(ai,"$(P)$(M)_SSISINGLETBITS_MON")
{
	field(DESC,"SSI singleturn bits")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_SSISINGLETBITS")
}

record(ai,"$(P)$(M)_SSIERRBITS_MON")
{
	field(DESC,"SSI err bits")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_SSIERRBITS")
}

record(ai,"$(P)$(M)_SSITIME_MON")
{
	field(DESC,"SSI timecode")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_SSITIME")
}

record(bi,"$(P)$(M)_SSIDATA_STATUS")
{
	field(DESC,"SSI timecode")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(ONAM,"Gray")
	field(ZNAM,"Binary")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_SSIDATA")
}

record(mbbo,"$(P)$(M)_SSIINPUT_CMD")
{
	field(DESC, "ssi input")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZRST, "Off")
	field(ONST, "Replace main")
	field(TWST, "Replace aux")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_SSIINPUT")
	field(FLNK, "$(P)$(M)_SSIINPUT_STATUS")
}

record(ao,"$(P)$(M)_SSITOTBITS_SP")
{
	field(DESC, "ssi total bits")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(VAL,  "25")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_SSITOTBITS")
	field(FLNK, "$(P)$(M)_SSITOTBITS_MON")
}

record(ao,"$(P)$(M)_SSISINGLETBITS_SP")
{
	field(DESC, "ssi single turn bits")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(VAL,  "13")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_SSISINGLETBITS")
	field(FLNK, "$(P)$(M)_SSISINGLETBITS_MON")
}

record(ao,"$(P)$(M)_SSIERRBITS_SP")
{
	field(DESC, "ssi err bits")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_SSIERRBITS")
	field(FLNK, "$(P)$(M)_SSIERRBITS_MON")
}

record(ao,"$(P)$(M)_SSITIME_SP")
{
	field(DESC, "ssi timecode")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(VAL,  "13")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_SSITIME")
	field(FLNK, "$(P)$(M)_SSITIME_MON")
}

record(bo,"$(P)$(M)_SSIDATA_CMD")
{
	field(DESC, "ssi dataform")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ONAM, "Gray")
	field(ZNAM, "Binary")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_SSIDATA")
	field(FLNK, "$(P)$(M)_SSIDATA_STATUS")
}

record(bi,"$(P)$(M)_SSIINVERT_STATUS")
{
	field(DESC, "SSI invert dir status")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(ZNAM, "Off")
  	field(ONAM, "On")
   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_SSIINVERT")
}

record(bo,"$(P)$(M)_SSIINVERT_CMD")
{
	field(DESC, "SSI invert dir cmd")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZNAM, "Off")
  	field(ONAM, "On")
	field(VAL,  "0")
   	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_SSIINVERT")
#	field(FLNK, "$(P)$(M)_SSIINVERT_STATUS")
}

########################
# EtherCat support

record(ao,"$(P)$(M)_ECATADDR_SP")
{
	field(DESC,"EtherCat Address")
	field(DTYP,"asynInt32")
	field(PINI,"YES")
	field(VAL, "1")
	field(PREC,"1")
	field(DRVH,"255")
	field(DRVL,"-255")
	field(EGU, "")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_ECAT_ADDR")
	field(FLNK,"$(P)$(M)_ECATADDR_MON")
}

record(ai,"$(P)$(M)_ECATADDR_MON")
{
	field(DESC,"EtherCat Address")
	field(DTYP,"asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_ECAT_ADDR")
	field(PREC, "1")
	field(EGU, "")
}

record(bi,"$(P)$(M)_ECATFLT_STATUS")
{
	field(DESC,"EtherCat Fault")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"I/O Intr")
	field(ZNAM, "Ok")
	field(ONAM, "Fault")
	field(OSV, "MAJOR")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_ECAT_FAULT")
}

record(bo,"$(P)$(M)_ECATFLTRST_CMD")
{
        field(DESC,"Fault reset")
        field(DTYP,"asynInt32")
        field(ZNAM,"Reset")
        field(ONAM,"Reset")
        field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_ECAT_FAULTRESET")
}

########################
# BiSS encoder support

record(mbbi,"$(P)$(M)_BISSINPUT_STATUS")
{
	field(DESC, "BiSS Input")
	field(SCAN,"$(SCAN)")
	field(DTYP, "asynInt32")
	field(ZRST, "Off")
	field(ONST, "Replace main")
	field(TWST, "Replace aux")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_BISSINPUT")
}

record(longin,"$(P)$(M)_BISSDATA1_MON")
{
	field(DESC,"BiSS Data Bits 1")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSDATA1")
}

record(longin,"$(P)$(M)_BISSDATA2_MON")
{
	field(DESC,"BiSS Data Bits 2")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSDATA2")
}

record(longin,"$(P)$(M)_BISSZP_MON")
{
	field(DESC,"BiSS Zero Pad Bits")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSZP")
}

record(longin,"$(P)$(M)_BISSCD_MON")
{
	field(DESC,"BiSS Clock Div")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSCD")
}

# See the SY command documentation
record(mbbi,"$(P)$(M)_BISSLEVEL_STATUS")
{
	field(DESC,"BiSS Active Level")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"$(SCAN)")
	field(ZRST, "Low/Low")
	field(ONST, "Low/High")
	field(TWST, "High/Low")
	field(THST, "High/High")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSLEVEL")
}

record(bi,"$(P)$(M)_BISSSTAT_TIMEOUT")
{
	field(DESC,"BiSS Timeout")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"I/O Intr")
	field(ZNAM, "No Timeout")
	field(ONAM, "Timeout")
	field(OSV, "MAJOR")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSSTAT_TIMEOUT")
}
record(bi,"$(P)$(M)_BISSSTAT_CRC")
{
	field(DESC,"BiSS CRC Status")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"I/O Intr")
	field(ZNAM, "Valid CRC")
	field(ONAM, "Invalid CRC")
	field(OSV, "MAJOR")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSSTAT_CRC")
}
record(bi,"$(P)$(M)_BISSSTAT_ERROR")
{
	field(DESC,"BiSS Error Status")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"I/O Intr")
	field(ZNAM, "No Error")
	field(ONAM, "Error")
	field(OSV, "MAJOR")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSSTAT_ERROR")
}
record(bi,"$(P)$(M)_BISSSTAT_WARN")
{
	field(DESC,"BiSS Warning")
	field(PINI,"YES")
	field(DTYP,"asynInt32")
	field(SCAN,"I/O Intr")
	field(ZNAM, "No Warning")
	field(ONAM, "Warning")
	field(OSV, "MAJOR")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSSTAT_WARN")
}
record(bo,"$(P)$(M)_BISSSTAT_POLL_CMD")
{
        field(DESC,"Poll BISS Status")
        field(DTYP,"asynInt32")
        field(VAL, "0")
        field(PINI,"YES")
        field(ZNAM,"No")
        field(ONAM,"Yes")
        field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_BISSSTAT_POLL")
        field(FLNK,"$(P)$(M)_BISSSTAT_POLL")
}
record(bi,"$(P)$(M)_BISSSTAT_POLL")
{
        field(DESC,"Poll BISS Status")
        field(PINI,"YES")
        field(DTYP,"asynInt32")
        field(SCAN,"I/O Intr")
        field(ZNAM, "No")
        field(ONAM, "Yes")
        field(INP, "@asyn($(PORT),$(ADDR))MOTOR_BISSSTAT_POLL")
}

record(mbbo,"$(P)$(M)_BISSINPUT_CMD")
{
	field(DESC, "BiSS Input")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZRST, "Off")
	field(ONST, "Replace main")
	field(TWST, "Replace aux")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_BISSINPUT")
	field(FLNK, "$(P)$(M)_BISSINPUT_STATUS")
}

record(longout,"$(P)$(M)_BISSDATA1_SP")
{
	field(DESC, "BiSS Data Bits 1")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(VAL,  "27")
	field(DRVL, "-38")
	field(DRVH, "38")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_BISSDATA1")
	field(FLNK, "$(P)$(M)_BISSDATA1_MON")
}

record(longout,"$(P)$(M)_BISSDATA2_SP")
{
	field(DESC, "BiSS Data Bits 2")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(VAL,  "27")
	field(DRVL, "0")
	field(DRVH, "38")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_BISSDATA2")
	field(FLNK, "$(P)$(M)_BISSDATA2_MON")
}

record(longout,"$(P)$(M)_BISSZP_SP")
{
	field(DESC, "BiSS Zero Pad Bits")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(VAL,  "0")
	field(DRVL, "0")
	field(DRVH, "7")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_BISSZP")
	field(FLNK, "$(P)$(M)_BISSZP_MON")
}

record(longout,"$(P)$(M)_BISSCD_SP")
{
	field(DESC, "BiSS Clock Div")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(VAL,  "14")
	field(DRVL, "4")
	field(DRVH, "26")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_BISSCD")
	field(FLNK, "$(P)$(M)_BISSCD_MON")
}

# See the SY command documentation
record(mbbo,"$(P)$(M)_BISSLEVEL_CMD")
{
	field(DESC, "BiSS Active Level")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZRST, "Low/Low")
	field(ONST, "Low/High")
	field(TWST, "High/Low")
	field(THST, "High/High")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_BISSLEVEL")
	field(FLNK, "$(P)$(M)_BISSLEVEL_STATUS")
}

########################

#Control the poll frequency for axis and encoder status.
record(ao,"$(P)$(M)_STATUS_POLL_DELAY_CMD")
{
	field(DESC, "Status Poll Delay")
	field(DTYP, "asynFloat64")
	field(PINI, "YES")
	field(VAL, "1")
	field(PREC, "1")
	field(DRVH, "10")
	field(DRVL, ".1")
	field(EGU, "s")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_STATUS_POLL_DELAY")
	field(FLNK, "$(P)$(M)_STATUS_POLL_DELAY_MON")
}
record(ai,"$(P)$(M)_STATUS_POLL_DELAY_MON")
{
	field(DESC, "Status Poll Delay")
	field(DTYP, "asynFloat64")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_STATUS_POLL_DELAY")
	field(PREC, "1")
	field(EGU, "s")
}

########################

record(mbbo,"$(P)$(M)_HOMEALLOWED_CMD")
{
	field(DESC, "Home allowed")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZRST, "None")
	field(ONST, "Reverse")
	field(TWST, "Forward")
	field(THST, "Both")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_HOME_ALLOWED")
	field(FLNK, "$(P)$(M)_HOMEALLOWED_STATUS")
}

record(mbbi,"$(P)$(M)_HOMEALLOWED_STATUS")
{
	field(DESC, "Home allowed")
	field(SCAN, "$(SCAN)")
	field(DTYP, "asynInt32")
	field(ZRST, "None")
	field(ONST, "Reverse")
	field(TWST, "Forward")
	field(THST, "Both")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(VAL,  "0")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_HOME_ALLOWED")
}

#Motor stop delay
record(ai,"$(P)$(M)_STOPDELAY_MON")
{
	field(DESC,"stop delay")
	field(DTYP,"asynFloat64")
	field(SCAN,"$(SCAN)")
	field(PREC,"$(PREC)")
	field(EGU, "s")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_STOP_DELAY")
}

record(ao,"$(P)$(M)_STOPDELAY_SP")
{
	field(DESC,"stop delay")
	field(DTYP,"asynFloat64")
	field(PREC,"$(PREC)")
	field(EGU, "s")
	field(VAL, "0.00")
	field(PINI, "YES")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_STOP_DELAY")
	field(FLNK,"$(P)$(M)_STOPDELAY_MON")
}

record(mbbo,"$(P)$(M)_AMPGAIN_CMD")
{
	field(DESC, "Amp gain")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZRST, "Zero")
	field(ONST, "One")
	field(TWST, "Two")
	field(THST, "Three")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_AMP_GAIN")
	field(FLNK, "$(P)$(M)_AMPGAIN_STATUS")
}

record(mbbi,"$(P)$(M)_AMPGAIN_STATUS")
{
	field(DESC, "Amp gain")
	field(SCAN, "$(SCAN)")
	field(DTYP, "asynInt32")
	field(ZRST, "Zero")
	field(ONST, "One")
	field(TWST, "Two")
	field(THST, "Three")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(VAL,  "0")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AMP_GAIN")
}

record(mbbo,"$(P)$(M)_AMPCLGAIN_CMD")
{
	field(DESC, "Amp CL gain")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZRST, "Zero")
	field(ONST, "Point five")
	field(TWST, "One")
	field(THST, "One point five")
	field(FRST, "Two")
	field(FVST, "Three")
	field(SXST, "Four")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(FRVL, "4")
	field(FVVL, "5")
	field(SXVL, "6")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_AMP_CURRENTLOOP_GAIN")
	field(FLNK, "$(P)$(M)_AMPCLGAIN_STATUS")
}

record(mbbi,"$(P)$(M)_AMPCLGAIN_STATUS")
{
	field(DESC, "Amp CL gain")
	field(SCAN, "$(SCAN)")
	field(DTYP, "asynInt32")
	field(ZRST, "Zero")
	field(ONST, "Point five")
	field(TWST, "One")
	field(THST, "One point five")
	field(FRST, "Two")
	field(FVST, "Three")
	field(SXST, "Four")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(FRVL, "4")
	field(FVVL, "5")
	field(SXVL, "6")
	field(VAL,  "0")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AMP_CURRENTLOOP_GAIN")
}

record(ao,"$(P)$(M)_AMPLC_SP")
{
	field(DESC, "Amp low current")
	field(DTYP, "asynInt32")
	field(DRVL, "0")
	field(DRVH, "4")
	field(PREC, "$(PREC)")
	field(PINI, "YES")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_AMP_LOWCURRENT")
	field(FLNK, "$(P)$(M)_AMPLC_MON")
}

record(ai,"$(P)$(M)_AMPLC_MON")
{
	field(DESC, "Amp low current")
	field(DTYP, "asynInt32")
	field(SCAN, "$(SCAN)")
	field(PREC, "$(PREC)")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AMP_LOWCURRENT")
}

record(ao,"$(P)$(M)_ERRLIMIT_SP")
{
	field(DESC,"error limit")
	field(PINI,"YES")
	field(VAL, "16384")
	field(EGU, "count")
	field(DTYP,"asynFloat64")
	field(OUT, "@asyn($(PORT),$(ADDR))MOTOR_ERRLIM")
	field(FLNK,"$(P)$(M)_ERRLIMIT_MON")
}

record(ai,"$(P)$(M)_ERRLIMIT_MON")
{
	field(DESC,"error limit")
	field(PINI,"YES")
	field(EGU, "count")
	field(DTYP,"asynFloat64")
	field(SCAN,"$(SCAN)")
	field(INP, "@asyn($(PORT),$(ADDR))MOTOR_ERRLIM")
}

record(ai,"$(P)$(M)_ERR_MON")
{
	field(DESC, "motor error")
	field(EGU,  "count")
	field(DTYP, "asynFloat64")
	field(SCAN, "I/O Intr")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_ERR")
}

record(ai,"$(P)$(M)_VELOCITYRAW_MON")
{
	field(DESC, "servo velocity raw")
	field(EGU,  "count /s")
	field(DTYP, "asynFloat64")
	field(SCAN, "I/O Intr")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_VELOCITY_RAW")
}

record(ai,"$(P)$(M)_VELOCITYEGU_MON")
{
	field(DESC, "servo velocity egu")
	field(EGU,  "$(EGU)/s")
	field(DTYP, "asynFloat64")
	field(SCAN, "I/O Intr")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_VELOCITY_EGU")
}

record(mbbo,"$(P)$(M)_OFFONERR_CMD")
{
	field(DESC, "error limit")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZRST, "Off")
	field(ONST, "Position error")
	field(TWST, "Limits")
	field(THST, "Both")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_OOE")
	field(FLNK, "$(P)$(M)_OFFONERR_STATUS")
}

record(mbbi,"$(P)$(M)_OFFONERR_STATUS")
{
	field(DESC, "error limit")
	field(PINI, "YES")
	field(SCAN, "$(SCAN)")
	field(DTYP, "asynInt32")
	field(ZRST, "Off")
	field(ONST, "Position error")
	field(TWST, "Limits")
	field(THST, "Both")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_OOE")
}

record(mbbi,"$(P)$(M)_AXIS_STATUS")
{
	field(DESC, "Axis chan")
	field(PINI, "YES")
	field(SCAN, "I/O Intr")
	field(DTYP, "asynInt32")
	field(ZRST, "A")
	field(ONST, "B")
	field(TWST, "C")
	field(THST, "D")
	field(FRST, "E")
	field(FVST, "F")
	field(SXST, "G")
	field(SVST, "H")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(FRVL, "4")
	field(FVVL, "5")
	field(SXVL, "6")
	field(SVVL, "7")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AXIS")
}

record(mbbo,"$(P)$(M)_MTRTYPE_CMD")
{
	field(DESC, "mtr type")
	field(DTYP, "asynInt32")
	field(ZRST, "Servo")
	field(ONST, "Rev Servo")
	field(TWST, "HA Stepper")
	field(THST, "LA Stepper")
	field(FRST, "Rev HA Stepper")
	field(FVST, "Rev LA Stepper")
	field(SXST, "PWM servo")
	field(SVST, "PWM rev servo")
	field(EIST, "EtherCat Position")
	field(NIST, "EtherCat Torque")
	field(TEST, "EtherCat Rev Torque")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(FRVL, "4")
	field(FVVL, "5")
	field(SXVL, "6")
	field(SVVL, "7")
	field(EIVL, "8")
	field(NIVL, "9")
	field(TEVL, "10")
	field(VAL,  "$(MTRTYPE)")
	field(PINI, "YES")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_TYPE")
	field(FLNK, "$(P)$(M)_MTRTYPE_CMD_FAN")
}

record(fanout, "$(P)$(M)_MTRTYPE_CMD_FAN")
{
	field(SELM, "All")
	#Changing motor type can change aux encoder also
	field(LNK1, "$(P)$(M)_MTRTYPE_STATUS")
	field(LNK2, "$(P)$(M)_AENCTYPE_STATUS")
}

record(mbbi,"$(P)$(M)_MTRTYPE_STATUS")
{
	field(DESC, "mtr type")
	field(PINI, "YES")
	field(SCAN, "$(SCAN)")
	field(DTYP, "asynInt32")
	field(ZRST, "Servo")
	field(ONST, "Rev Servo")
	field(TWST, "HA Stepper")
	field(THST, "LA Stepper")
	field(FRST, "Rev HA Stepper")
	field(FVST, "Rev LA Stepper")
	field(SXST, "PWM servo")
	field(SVST, "PWM rev servo")
	field(EIST, "EtherCat Position")
	field(NIST, "EtherCat Torque")
	field(TEST, "EtherCat Rev Torque")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(FRVL, "4")
	field(FVVL, "5")
	field(SXVL, "6")
	field(SVVL, "7")
	field(EIVL, "8")
	field(NIVL, "9")
	field(TEVL, "10")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_TYPE")
}

record(mbbo,"$(P)$(M)_MENCTYPE_CMD")
{
	field(DESC, "main enc type")
	field(DTYP, "asynInt32")
	field(ZRST, "Normal Quadrature")
	field(ONST, "Pulse and Dir")
	field(TWST, "Reverse Quadrature")
	field(THST, "Rev Pulse and Dir")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(VAL,  "0")
	field(PINI, "YES")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_MAIN_ENCODER")
	field(FLNK, "$(P)$(M)_MENCTYPE_STATUS")
}

record(mbbi,"$(P)$(M)_MENCTYPE_STATUS")
{
	field(DESC, "main enc type")
	field(PINI, "YES")
	field(SCAN, "$(SCAN)")
	field(DTYP, "asynInt32")
	field(ZRST, "Normal Quadrature")
	field(ONST, "Pulse and Dir")
	field(TWST, "Reverse Quadrature")
	field(THST, "Rev Pulse and Dir")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_MAIN_ENCODER")
}

record(mbbo,"$(P)$(M)_AENCTYPE_CMD")
{
	field(DESC, "Aux enc type")
	field(DTYP, "asynInt32")
	field(ZRST, "Normal Quadrature")
	field(ONST, "Pulse and Dir")
	field(TWST, "Reverse Quadrature")
	field(THST, "Rev Pulse and Dir")
	field(ZRVL, "0")
	field(ONVL, "4")
	field(TWVL, "8")
	field(THVL, "12")
	field(VAL,  "0")
	field(PINI, "YES")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_AUX_ENCODER")
	field(FLNK, "$(P)$(M)_AENCTYPE_STATUS")
}

record(mbbi,"$(P)$(M)_AENCTYPE_STATUS")
{
	field(DESC, "Aux enc type")
	field(PINI, "YES")
	field(SCAN, "$(SCAN)")
	field(DTYP, "asynInt32")
	field(ZRST, "Normal Quadrature")
	field(ONST, "Pulse and Dir")
	field(TWST, "Reverse Quadrature")
	field(THST, "Rev Pulse and Dir")
	field(ZRVL, "0")
	field(ONVL, "4")
	field(TWVL, "8")
	field(THVL, "12")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AUX_ENCODER")
}

#Wrong limit protection
record(bo,"$(P)$(M)_WLP_CMD")
{
	field(DESC, "wrong limit protect")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZNAM, "Off")
	field(ONAM, "On")
	field(VAL,  "1")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_WLP")	
	field(FLNK, "$(P)$(M)_WLP_STATUS")
}

record(bi,"$(P)$(M)_WLP_STATUS")
{
	field(DESC, "wrong limit protect")
	field(DTYP, "asynInt32")
	field(SCAN, "$(SCAN)")
	field(ZNAM, "Off")
  	field(ONAM, "On")
   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_WLP")
}

record(bi,"$(P)$(M)_WLPACTIVE_STATUS")
{
	field(DESC, "wlp activated")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(ZNAM, "OK")
	field(ZSV,  "NO_ALARM")
  	field(ONAM, "Stopped!")
	field(OSV,  "MAJOR")
   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_WLP_ACTIVE")
}

#Motor power auto on/off between moves
record(bo,"$(P)$(M)_AUTOONOFF_CMD")
{
	field(DESC, "mtr auto on/off")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZNAM, "Off")
	field(ONAM, "On")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_ONOFF")
	field(FLNK, "$(P)$(M)_AUTOONOFF_STATUS")
}

record(bi,"$(P)$(M)_AUTOONOFF_STATUS")
{
	field(DESC, "mtr auto on/off")
	field(DTYP, "asynInt32")
	field(SCAN, "$(SCAN)")
	field(ZNAM, "Off")
  	field(ONAM, "On")
   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_ONOFF")
}

#Motor auto power on delay
record(ai,"$(P)$(M)_ONDELAY_MON")
{
	field(DESC, "mtr pwr on dly")
	field(DTYP, "asynFloat64")
	field(SCAN, "$(SCAN)")
	field(PREC, "$(PREC)")
	field(EGU,  "s")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_ONDELAY")
}

record(ao,"$(P)$(M)_ONDELAY_SP")
{
	field(DESC, "mtr pwr on dly")
	field(DTYP, "asynFloat64")
	field(PREC, "$(PREC)")
	field(EGU,  "s")
	field(VAL,  ".2")
	field(DRVH, "3")
	field(DRVL, ".001")
	field(PINI, "YES")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_ONDELAY")
	field(FLNK, "$(P)$(M)_ONDELAY_MON")
}

#Motor auto power off delay
record(ai,"$(P)$(M)_OFFDELAY_MON")
{
	field(DESC, "mtr pwr off dly")
	field(DTYP, "asynFloat64")
	field(SCAN, "$(SCAN)")
	field(PREC, "$(PREC)")
	field(EGU,  "s")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_OFFDELAY")
}

record(ao,"$(P)$(M)_OFFDELAY_SP")
{
	field(DESC, "mtr pwr off dly")
	field(DTYP, "asynFloat64")
	field(PREC, "$(PREC)")
	field(EGU,  "s")
	field(VAL,  ".2")
	field(DRVH, "3")
	field(DRVL, ".001")
	field(PINI, "YES")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_OFFDELAY")
	field(FLNK, "$(P)$(M)_OFFDELAY_MON")
}

#Motor brake status
record(bi,"$(P)$(M)_BRAKE_STATUS")
{
	field(DESC, "mtr brake")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(ZNAM, "Off")
  	field(ONAM, "On")
   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_BRAKE")
}

#Motor auto brake between moves
record(bo,"$(P)$(M)_AUTOBRAKE_CMD")
{
	field(DESC, "mtr auto brake")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZNAM, "Off")
	field(ONAM, "On")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_BRAKE")
	field(FLNK, "$(P)$(M)_AUTOBRAKE_STATUS")
}

record(bi,"$(P)$(M)_AUTOBRAKE_STATUS")
{
	field(DESC, "mtr auto brake")
	field(DTYP, "asynInt32")
	field(SCAN, "$(SCAN)")
	field(ZNAM, "Off")
  	field(ONAM, "On")
   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_BRAKE")
}

#Motor auto brake port
record(ai,"$(P)$(M)_BRAKEPORT_MON")
{
	field(DESC, "mtr brake digport")
	field(DTYP, "asynInt32")
	field(SCAN, "$(SCAN)")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_BRAKEPORT")
}

record(ao,"$(P)$(M)_BRAKEPORT_SP")
{
	field(DESC, "mtr brake digport")
	field(DTYP, "asynInt32")
	field(PINI, "YES")
	field(DRVH, "16")
	field(DRVL, "-1")
	field(VAL,  "-1")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_BRAKEPORT")
	field(FLNK, "$(P)$(M)_BRAKEPORT_MON")
}

#Motor auto brake on delay
record(ai,"$(P)$(M)_BRAKEONDELAY_MON")
{
	field(DESC, "mtr brake on delay")
	field(DTYP, "asynFloat64")
	field(SCAN, "$(SCAN)")
	field(EGU,  "s")
	field(PREC, "$(PREC)")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_BRAKEONDELAY")
}

record(ao,"$(P)$(M)_BRAKEONDELAY_SP")
{
	field(DESC, "mtr brake on delay")
	field(DTYP, "asynFloat64")
	field(PINI, "YES")
	field(EGU,  "s")
	field(PREC, "$(PREC)")
	field(VAL,  ".2")
	field(DRVH, "3")
	field(DRVL, ".001")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_AUTO_BRAKEONDELAY")
	field(FLNK, "$(P)$(M)_BRAKEONDELAY_MON")
}

#Enable/Disable Hardware Limits using LD command
#The controller still reports the limit switch status 
#and so in the driver we don't report the limits if 
#we choose to disable limits using this command.
record(mbbo,"$(P)$(M)_LIMITDISABLE_CMD")
{
	field(DESC, "Limit Disable")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(ZRST, "Off")
	field(ONST, "Fwd Disabled")
	field(TWST, "Rev Disabled")
	field(THST, "Both Disabled")
	field(VAL,  "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_LIMIT_DISABLE")
	field(FLNK, "$(P)$(M)_LIMITDISABLE_STATUS")
}

record(mbbi,"$(P)$(M)_LIMITDISABLE_STATUS")
{
	field(DESC, "Limit Disable")
	field(DTYP, "asynInt32")
	field(SCAN, "$(SCAN)")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(THVL, "3")
	field(ZRST, "Off")
	field(ONST, "Fwd Disabled")
	field(TWST, "Rev Disabled")
	field(THST, "Both Disabled")
   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_LIMIT_DISABLE")
}

# Record to define a tolerance when determining encoder motion and direction
record(longout,"$(P)$(M)_ENC_TOLERANCE_SP")
{
	field(DESC, "Encoder Tolerance")
	field(DTYP, "asynInt32")
	field(PINI, "YES")
	field(EGU,  "count")
	field(VAL,  "0")
	field(DRVL, "0")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_ENCODER_TOLERANCE")
}
record(longin,"$(P)$(M)_ENC_TOLERANCE_MON")
{
	field(DESC, "Encoder Tolerance")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(EGU, "count")
	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_ENCODER_TOLERANCE")
}

##
## converters for old EDEL encoder deadband names
## these were like ENC_TOLERANCE but in physical units
## 
## first time we swap old->new driver we will have an autosaved EDEL_SP
## so only apply value if > 0
##
record(ao,"$(P)$(M)_EDEL_SP")
{
    field(EGU, "mm")
    field(PINI, "YES")
    field(VAL, "0")
    field(FLNK, "$(P)$(M)_EDEL_SP_")
}

record(calcout,"$(P)$(M)_EDEL_SP_")
{
    field(INPA, "$(P)$(M)_EDEL_SP")
    field(INPB, "$(P)$(M).ERES")
    field(CALC, "B != 0 ? A/B : 0")
    field(OOPT, "When Non-zero")
    field(OUT, "$(P)$(M)_ENC_TOLERANCE_SP PP")
}

record(ai,"$(P)$(M)_EDEL_MON")
{
    field(EGU, "mm")
}

record(calcout,"$(P)$(M)_EDEL_MON_")
{
    field(INPA, "$(P)$(M)_ENC_TOLERANCE_MON CP")
    field(INPB, "$(P)$(M).ERES CP")
    field(CALC, "A * B")
    field(OUT, "$(P)$(M)_EDEL_MON PP")
}

####

record(bi,"$(P)$(M)_ON_STATUS")
{
	field(DESC, "Mtr on status")
	field(DTYP, "asynInt32")
	field(SCAN, "I/O Intr")
	field(ZNAM, "Off")
   	field(ZSV,  "MINOR")
  	field(ONAM, "On")
  	field(OSV,  "NO_ALARM")
   	field(INP,  "@asyn($(PORT),$(ADDR))MOTOR_STATUS_POWERED")
}

#This mbbi/mbbo is deliberately last, so motor on/off function is 
#always after other defaults have been set (eg. Limits, and encoder)
record(mbbo,"$(P)$(M)_ON_CMD")
{
	field(DESC, "Motor on cmd")
	field(ZRST, "Off")
	field(ONST, "On")
	field(TWST, "As is")
	field(ZRVL, "0")
	field(ONVL, "1")
	field(TWVL, "2")
	field(PINI, "YES")
	field(VAL,  "$(MTRON)")
	field(FLNK, "$(P)$(M)_ON_CMD_CALC")
}

record(calcout,"$(P)$(M)_ON_CMD_CALC")
{
	field(INPA, "$(P)$(M)_ON_CMD NPP")
	field(OUT,  "$(P)$(M)_ON_CMD_DO PP")
	field(CALC, "A < 2")
	field(OCAL, "A")
	field(DOPT, "Use OCAL")
	field(OOPT, "When Non-zero")
}

record(longout,"$(P)$(M)_ON_CMD_DO")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_CLOSED_LOOP")
	field(FLNK, "$(P)$(M)_ON_STATUS")
}

## if we don't send moves in the usual way, put a string here and %f will be replaced by
## the position requested and sent to the galil
record(stringout,"$(P)$(M)_MOVE_CMD")
{
	field(DESC, "Special Motor Move cmd")
	field(DTYP, "asynOctetWrite")
	field(PINI, "YES")
	field(VAL,  "")
	field(OUT,  "@asyn($(PORT),$(ADDR))MOVE_COMMAND")
}

##
## calculate the live difference between motor and encoder position
## only calculate if UEIP (E) is true and an encoder is also actually
## present (as per relevant MSTA bit, F&256)
## In addition only calculate when moving (G == 0) to avoid noisy
## encoder post move triggering recording. Store calculation
## result in H so if moving (G != 0) can return previous calc value
##
record(calcout,"$(P)$(M)_MTRENC_DIFF")
{
	field(DESC, "In motion encoder motor difference")
	field(INPA, "$(P)$(M).RMP CP")
	field(INPB, "$(P)$(M).MRES CP")
	field(INPC, "$(P)$(M).REP CP")
	field(INPD, "$(P)$(M).ERES CP")
	field(INPE, "$(P)$(M).UEIP CP")
	field(INPF, "$(P)$(M).MSTA CP")
	field(INPG, "$(P)$(M).DMOV CP")
	field(CALC, "H:=(G=0?((E&&(F&256))?(ABS(A*B)-ABS(C*D)):0):H);H")
}

##
## determine the difference between motor and encoder position
## when motion complete
##
record(calcout,"$(P)$(M)_MTRENC_DRIFT_")
{
	field(DESC, "Encoder motor drift calc")
	field(INPA, "$(P)$(M)_MTRENC_DIFF CP")
	field(INPB, "$(P)$(M).DMOV CP")
	field(CALC, "B")
	field(OOPT, "When Non-zero")
	field(DOPT, "Use OCAL")
	field(OCAL, "A")
	field(OUT, "$(P)$(M)_MTRENC_DRIFT PP")
}

##
## record difference between motor and encoder position when motion complete
##
record(ai,"$(P)$(M)_MTRENC_DRIFT")
{
    field(DESC, "Encoder motor drift")
    field(EGU, "$(EGU)")
    info(archive, "VAL")
}

## Hold the threshold value
record(ao, "$(P)$(M)_THRESHOLD")
{
   field(DESC, "Encoder and motor threshold")
   field(EGU, "$(EGU)")
   field(PREC, 6)
   field(VAL, 0)
}

record(calcout, "$(P)$(M)_DEFAULT_THRESHOLD")
{
    field(DESC, "Default threshold")
    field(INPA, "$(P)$(M).MRES CP")
    field(INPB, "$(P)$(M).ERES CP")
    field(INPC, "$(P)$(M)_THRESHOLD")
    field(CALC, "C=0?(10*(A>B?A:B)):C")
    field(OUT, "$(P)$(M)_THRESHOLD PP")
    field(EGU, "$(EGU)")
}

##
## check if the drift is above the threshold limit
##
record(calcout, "$(P)$(M)_DRIFT_THRESHOLD_CHECK")
{
    field(DESC, "Drift and threshold check")
    field(INPA, "$(P)$(M)_THRESHOLD.VAL CP")
    field(INPB, "$(P)$(M)_MTRENC_DRIFT.VAL CP")
    field(CALC, "B>A")
    
}

#end



# monitor the motor status and update a string field with results
record(aSub, "$(P)$(M):_MSTACALC")
{
    field(SNAM, "displayMotorMSTA")
	field(INPA, "$(P)$(M).MSTA CP")
	field(FTA, "ULONG")
	field(OUTA, "$(P)$(M)_MSTA_STR PP")
	field(FTVA, "CHAR")
	field(NOVA, "512")	
}

record(waveform, "$(P)$(M)_MSTA_STR")
{
	field(NELM, "512")
	field(FTVL, "CHAR")
	field(DESC, "Text version of motor MSTA")
}

record(aSub, "$(P)$(M):_STATUSCALC")
{
    field(SNAM, "displayMotorMSTASimple")
	field(INPA, "$(P)$(M).MSTA CP")
	field(FTA, "ULONG")
	field(OUTA, "$(P)$(M)_STATUS PP")
	field(FTVA, "STRING")
	field(NOVA, "1")	
}

# allow splitting out of MSTA
record(mbbiDirect, "$(P)$(M):_MSTABITS")
{
    field(INP, "$(P)$(M).MSTA CP")
}

record(bi, "$(P)$(M)_HOMED")
{
    field(DESC, "Motor Homed")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(INP, "$(P)$(M):_MSTABITS.BE CP")
}

record(stringin, "$(P)$(M)_STATUS")
{
    field(DESC, "Simple Text version of motor MSTA")
}

record(stringin, "$(P)$(M)_MTR")
{
    field(VAL, "$(M)")
}

record(aSub,"$(P)$(M)_ERRCALC")
{
    field(SNAM,"checkMotorError")
    field(SCAN,"Passive")
    field(INPA,"$(P)$(M).MSTA CP")
	field(FTA, "ULONG")
    field(INPB,"$(P)$(M).LVIO CP")
	field(FTB, "SHORT")
    field(INPC,"$(P)$(M).HLS CP")
	field(FTC, "SHORT")
    field(INPD,"$(P)$(M).LLS CP")
	field(FTD, "SHORT")
    field(INPE,"$(P)$(M).STAT CP")
	field(FTE, "USHORT")
    field(INPF,"$(P)$(M).SEVR CP")
	field(FTF, "USHORT")
    field(INPG,"$(P)$(M)_MTR")
	field(FTG, "STRING")
	field(FTVA, "STRING")
	field(FTVB, "ULONG")
	# we want to process _ERRCALC_FAN only if the error message changes, so use OUTA not FLNK
	# but strings outputs cannot be used to write to .PROC fields, so need to use intermediate string record 
	field(OUTA, "$(P)$(M)_ERRCALC_MESS PP")
}

record(stringout, "$(P)$(M)_ERRCALC_MESS")
{
}

record(stringout, "$(P)$(M)_PERROR")
{
    field(OMSL, "closed_loop")
    field(DOL, "$(P)$(M)_ERRCALC_MESS CP")
    field(DTYP, "stdio")
    field(OUT, "@errlog")
}

# Expose the DMOV field as a PV record, so it can be access from a block
record(ai,"$(P)$(M):DMOV")
{
	field(DESC, "Done move?")
    field(SCAN, "Passive")
    field(DTYP, "Soft Channel")
    field(INP, "$(P)$(M).DMOV CP")
}

record(stringin, "$(P)$(M)_IOCNAME"){
    field(DESC, "IOC name eg GALIL_01")
    field(VAL, "$(IOCNAME=)")
}

record(scalcout, "$(P)$(M):MANAGERMODE")
{
    field(ASG, "READONLY")
    field(DESC, "Non-zero if manager is required")
    field(PINI, "YES")
    field(INPA, "$(PVPREFIX)CS:MANAGER CP")
    field(BB, "$(ASG)")
    field(CALC, "A = 0 && BB = 'MANAGER'")
    field(OOPT, "Every Time")
}

#Below records are used to extract data from MR
#and pass to driver



record(ao,"$(P)$(M)_MOT_ENC_SYNC_TOL_SP") {
    field(DESC, "Motor encoder sync tol")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))MOTOR_ENC_TOL")
    field(PREC, "$(PREC)")
	field(EGU, "$(EGU)")
	field(VAL, "0")
	field(PINI, "YES")
}

# Allow setting MRES/ERES as inverse

record(ao, "$(P)$(M):INV_MRES")
{
	field(DESC, "Set the motor res in steps per EGU")
	field(FLNK, "$(P)$(M):INV_MRES:SP_CALC")
	field(PREC, "3")
}

record(calcout, "$(P)$(M):INV_MRES:SP_CALC")
{
	field(INPA, "$(P)$(M):INV_MRES")
	field(CALC, "1/A")
	field(OUT, "$(P)$(M).MRES")
	field(SDIS, "$(P)$(M):INV_MRES_CALC.PACT")
	field(OOPT, "On Change")
}

record(calcout, "$(P)$(M):INV_MRES_CALC")
{
	field(INPA, "$(P)$(M).MRES CP")
	field(CALC, "1/A")
	field(OUT, "$(P)$(M):INV_MRES PP")
	field(OOPT, "On Change")
}

record(ao, "$(P)$(M):INV_ERES")
{
	field(DESC, "Set the encoder res in steps per EGU")
	field(FLNK, "$(P)$(M):INV_ERES:SP_CALC")
	field(PREC, "3")
}

record(calcout, "$(P)$(M):INV_ERES:SP_CALC")
{
	field(INPA, "$(P)$(M):INV_ERES")
	field(CALC, "1/A")
	field(OUT, "$(P)$(M).ERES")
	field(SDIS, "$(P)$(M):INV_ERES_CALC.PACT")
	field(OOPT, "On Change")
}

record(calcout, "$(P)$(M):INV_ERES_CALC")
{
	field(INPA, "$(P)$(M).ERES CP")
	field(CALC, "1/A")
	field(OUT, "$(P)$(M):INV_ERES PP")
	field(OOPT, "On Change")
}

##
## these generate an averages encoder position and
## EPOS_AV can be used with the RDBL motor record field to
## have the motor display and use an averaged encoder value
## for operations
##
## set RDBL to be "EPOS_AV CP MS"
## set URIP to Yes
## set RDLY for a time long enough that all values covered by ENCAVNSAMP were taken when a motion reached position,
##          otherwise retries get confused as aveage is scewed by values from when in-motion  
## set ENCAVNSAMP to large enough number to get a good average
## if encoder is noisy enough leave ENCAVSCAN as Passive and CP triggering will be enough, otherwise set a SCAN value
## 
record(calcout, "$(P)$(M):_EPOS_CALC")
{
    field(INPA, "$(P)$(M).REP CP MS")
    field(INPB, "$(P)$(M).ERES CP MS")
    field(CALC, "A * B")
    field(SCAN, "$(ENCAVSCAN=Passive)")
    field(FLNK, "$(P)$(M):_EPOS_CB")
}

record(compress, "$(P)$(M):_EPOS_CB")
{
    field(ALG, "Circular Buffer")
    field(INP, "$(P)$(M):_EPOS_CALC NPP MS")
    field(NSAM, "$(ENCAVNSAMP=10)")
    field(FLNK, "$(P)$(M):EPOS_AV")
}

## average encoder dial position
record(compress, "$(P)$(M):EPOS_AV")
{
    field(DESC, "Averaged encoder dial pos")
    field(ALG, "N to 1 Average")
    field(INP, "$(P)$(M):_EPOS_CB NPP MS")
    field(NSAM, "1")
    field(N, "$(ENCAVNSAMP=10)")
}

## if URIP is enabled, sync positions
record(calcout, "$(P)$(M):_EPOS_INIT")
{
    field(INPA, "$(P)$(M).URIP CP")
    field(CALC, "A")
    field(OOPT, "When Non-zero")
    field(SCAN, "Passive")
    field(VAL, "1")
    field(OUT, "$(P)$(M):_EPOS_SYNC.PROC CA")
}

## delay sync to allow startup to finish
record(seq, "$(P)$(M):_EPOS_SYNC")
{
    field(DO0, "1")
    field(DLY0, "8")
    field(LNK0, "$(P)$(M).SYNC CA")
}

## listen for motor disable event signalled from controller PV
record(bo, "$(P)$(M)_ctrl_disable")
{
    field(EVNT, "DisableAllMotors")
    field(SCAN, "Event")
    field(VAL, "1")
    field(ZNAM,"Enable")
    field(ONAM,"Disable")
    field(OUT, "$(P)$(M)_able PP")
}
